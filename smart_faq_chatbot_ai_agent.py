# -*- coding: utf-8 -*-
"""Smart FAQ Chatbot AI Agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DAtTrS2bg4lxT4BDcEnTLU6J7Vru5uK1

#Smart FAQ Chatbot AI Agent
## Applied Artificial Intelligence Project

**Date:** 29 December 2025

---

###  Project Overview
This notebook implements an intelligent FAQ chatbot using:
- **TF-IDF Vectorization** for text analysis
- **Cosine Similarity** for matching queries to FAQs
- **Small Talk Detection** for natural conversation
- **Visual Analytics** for performance monitoring


*   List item
*   List item

---

##  STEP 1: Environment Setup
Loading required Python modules for:
- This installs all necessary Python packages for the AI chatbot
- Expected time: 30-60 seconds
##  STEP 2: Import Libraries
Loading required Python modules for:
- Text processing (regex)
- Machine learning (sklearn)
- Data visualization (matplotlib, seaborn)
- Numerical operations (numpy)
"""

# STEP 1: Install and Import Libraries
!pip install scikit-learn numpy matplotlib seaborn -q

# STEP 2: Import libraries
import re
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from datetime import datetime
from collections import Counter

# Set visualization style
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (10, 6)

"""---

##  STEP 3: Build the AI Agent Class

### Class Structure
The `EnhancedFAQAgent` class contains:
1. **Knowledge Base** (FAQ database + Small talk responses)
2. **TF-IDF Vectorizer** (Converts text to numerical vectors)
3. **Preprocessing** (Cleans user input)
4. **Small Talk Detection** (Recognizes greetings, thanks, etc.)
5. **AI Matching** (Finds best FAQ using Cosine Similarity)
6. **Response Generation** (Returns answer with confidence score)
7. **Analytics** (Tracks performance metrics)
8. **Visualization** (Creates charts for PPT)

### Key AI Concepts Used
- **TF-IDF**: Weighs words by importance, not just frequency
- **Cosine Similarity**: Measures "angle" between text vectors
- **Threshold**: Minimum confidence (30%) to accept a match
"""

# STEP 3: Define the AI Agent Class
class EnhancedFAQAgent:
    """
    Advanced FAQ Chatbot with:
    - TF-IDF Vectorization for semantic matching
    - Cosine Similarity for finding best matches
    - Small talk handling for natural conversation
    - Confidence scoring and analytics
    """

    def __init__(self):
        # Main FAQ Knowledge Base
        self.faq_database = {
            "What are your business hours?": "We are open Monday to Friday, 9 AM to 6 PM IST.",
            "How do I reset my password?": "Click 'Forgot Password' on the login page, enter your email, and follow the reset link sent to you.",
            "What is your refund policy?": "We offer full refunds within 30 days of purchase for unused products.",
            "How can I track my order?": "Login to your account and visit 'My Orders' section. Click on the order to see tracking details.",
            "Do you offer international shipping?": "Yes, we ship to over 50 countries. Shipping costs vary by location.",
            "How do I contact customer support?": "Email us at support@company.com or call +91-1234567890 during business hours.",
            "What payment methods do you accept?": "We accept credit cards, debit cards, UPI, net banking, and digital wallets.",
            "How long does delivery take?": "Standard delivery takes 5-7 business days. Express delivery available in 2-3 days.",
            "Can I cancel my order?": "Yes, orders can be cancelled within 24 hours of placing them through your account dashboard.",
            "Do you have a mobile app?": "Yes, download our app from Google Play Store or Apple App Store.",
            "How do I create an account?": "Click 'Sign Up' on our homepage, enter your details, and verify your email address.",
            "What is your return process?": "Initiate a return from 'My Orders', print the return label, and ship the item back to us.",
            "Do you offer gift cards?": "Yes, gift cards are available in denominations of ₹500, ₹1000, and ₹2000.",
            "How do I apply a coupon code?": "Enter your coupon code at checkout in the 'Promo Code' field before payment.",
            "Is my payment information secure?": "Yes, we use 256-bit SSL encryption and PCI-DSS compliant payment gateways."
        }

        # Small Talk Database for Natural Interaction
        self.small_talk = {
            "greetings": {
                "patterns": ["hello", "hi", "hey", "good morning", "good afternoon", "good evening"],
                "responses": [
                    "Hello! How can I help you today?",
                    "Hi there! What can I assist you with?",
                    "Hey! I'm here to answer your questions."
                ]
            },
            "gratitude": {
                "patterns": ["thank you", "thanks", "appreciate it", "helpful"],
                "responses": [
                    "You're welcome! Feel free to ask if you have more questions.",
                    "Happy to help! Is there anything else you'd like to know?",
                    "Glad I could assist you!"
                ]
            },
            "wellbeing": {
                "patterns": ["how are you", "how do you do", "what's up"],
                "responses": [
                    "I'm functioning perfectly! How can I assist you today?",
                    "I'm doing great, thanks for asking! What can I help you with?",
                    "All systems operational! What would you like to know?"
                ]
            },
            "farewell": {
                "patterns": ["bye", "goodbye", "see you", "take care"],
                "responses": [
                    "Goodbye! Have a great day!",
                    "Take care! Feel free to return anytime.",
                    "See you later! Don't hesitate to reach out if you need help."
                ]
            }
        }

        self.questions = list(self.faq_database.keys())
        self.answers = list(self.faq_database.values())

        # Initialize TF-IDF Vectorizer
        # TF-IDF = Term Frequency - Inverse Document Frequency
        # It weighs words by importance, not just frequency
        self.vectorizer = TfidfVectorizer(ngram_range=(1, 2))  # Consider 1 and 2-word phrases
        self.question_vectors = self.vectorizer.fit_transform(self.questions)

        # Analytics tracking
        self.conversation_history = []
        self.query_types = {"faq_match": 0, "small_talk": 0, "no_match": 0}

    def preprocess_query(self, query):
        """Clean and normalize user input"""
        query = query.lower().strip()
        query = re.sub(r'[^\w\s?]', '', query)
        return query

    def check_small_talk(self, query):
        """
        Check if query is small talk before searching FAQs
        Returns: (is_small_talk, response)
        """
        processed_query = self.preprocess_query(query)

        for category, data in self.small_talk.items():
            for pattern in data["patterns"]:
                if pattern in processed_query:
                    response = np.random.choice(data["responses"])
                    self.query_types["small_talk"] += 1
                    return True, response, category

        return False, None, None

    def find_best_match(self, user_query, threshold=0.3):
        """
        Find most similar FAQ using Cosine Similarity

        Cosine Similarity Formula: similarity = (A · B) / (||A|| ||B||)
        - A and B are TF-IDF vectors of the query and FAQ questions
        - Result ranges from 0 (no similarity) to 1 (identical)
        - We use threshold to determine minimum acceptable similarity

        threshold: minimum similarity score (0-1) to consider a match
        """
        processed_query = self.preprocess_query(user_query)

        # Convert query to TF-IDF vector
        query_vector = self.vectorizer.transform([processed_query])

        # Calculate cosine similarity between query and all FAQ questions
        # This measures the "angle" between vectors in multi-dimensional space
        similarities = cosine_similarity(query_vector, self.question_vectors)[0]

        # Find the FAQ with highest similarity
        best_match_idx = np.argmax(similarities)
        best_score = similarities[best_match_idx]

        if best_score >= threshold:
            self.query_types["faq_match"] += 1
            return self.answers[best_match_idx], best_score, self.questions[best_match_idx]
        else:
            self.query_types["no_match"] += 1
            return None, best_score, None

    def respond(self, user_query):
        """Generate intelligent response to user query"""

        # First check if it's small talk
        is_small_talk, small_talk_response, talk_category = self.check_small_talk(user_query)

        if is_small_talk:
            self.conversation_history.append({
                'timestamp': datetime.now().strftime("%H:%M:%S"),
                'user_query': user_query,
                'response_type': 'small_talk',
                'category': talk_category,
                'response': small_talk_response,
                'confidence': 100.0
            })

            return {
                'status': 'small_talk',
                'response': small_talk_response,
                'confidence': 100.0,
                'category': talk_category
            }

        # If not small talk, search FAQ database
        answer, confidence, matched_question = self.find_best_match(user_query)

        timestamp = datetime.now().strftime("%H:%M:%S")

        if answer:
            self.conversation_history.append({
                'timestamp': timestamp,
                'user_query': user_query,
                'response_type': 'faq_match',
                'matched_question': matched_question,
                'confidence': confidence * 100,
                'response': answer
            })

            return {
                'status': 'success',
                'response': answer,
                'confidence': round(confidence * 100, 2),
                'matched_faq': matched_question
            }
        else:
            fallback_response = ("I apologize, I couldn't find a relevant answer in my knowledge base. "
                               "Your question might be too specific or outside my current expertise. "
                               "Please contact our support team at support@company.com or call +91-1234567890.")

            self.conversation_history.append({
                'timestamp': timestamp,
                'user_query': user_query,
                'response_type': 'no_match',
                'confidence': confidence * 100,
                'response': fallback_response
            })

            return {
                'status': 'no_match',
                'response': fallback_response,
                'confidence': round(confidence * 100, 2),
                'matched_faq': None
            }

    def get_analytics(self):
        """Return comprehensive analytics"""
        total_queries = len(self.conversation_history)

        if total_queries == 0:
            return {"error": "No queries processed yet"}

        avg_confidence = np.mean([entry['confidence'] for entry in self.conversation_history])

        return {
            'total_queries': total_queries,
            'query_distribution': self.query_types,
            'average_confidence': round(avg_confidence, 2),
            'conversation_history': self.conversation_history
        }

    def visualize_performance(self):
        """Create visualizations for PPT"""
        if len(self.conversation_history) == 0:
            print("No data to visualize yet. Please interact with the chatbot first.")
            return

        # Create figure with subplots
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        fig.suptitle('Smart FAQ Chatbot - Performance Analytics', fontsize=16, fontweight='bold')

        # 1. Confidence Score Distribution
        confidences = [entry['confidence'] for entry in self.conversation_history]
        axes[0, 0].hist(confidences, bins=10, color='skyblue', edgecolor='black', alpha=0.7)
        axes[0, 0].axvline(np.mean(confidences), color='red', linestyle='--',
                          label=f'Mean: {np.mean(confidences):.1f}%')
        axes[0, 0].set_xlabel('Confidence Score (%)')
        axes[0, 0].set_ylabel('Frequency')
        axes[0, 0].set_title('Distribution of Confidence Scores')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)

        # 2. Query Type Breakdown
        query_types = list(self.query_types.keys())
        query_counts = list(self.query_types.values())
        colors = ['#2ecc71', '#3498db', '#e74c3c']

        axes[0, 1].pie(query_counts, labels=query_types, autopct='%1.1f%%',
                      colors=colors, startangle=90)
        axes[0, 1].set_title('Query Type Distribution')

        # 3. Confidence Scores Over Time
        recent_queries = self.conversation_history[-10:]  # Last 10 queries
        query_numbers = range(1, len(recent_queries) + 1)
        recent_confidences = [entry['confidence'] for entry in recent_queries]

        axes[1, 0].plot(query_numbers, recent_confidences, marker='o',
                       linewidth=2, markersize=8, color='#9b59b6')
        axes[1, 0].fill_between(query_numbers, recent_confidences, alpha=0.3, color='#9b59b6')
        axes[1, 0].set_xlabel('Query Number (Recent)')
        axes[1, 0].set_ylabel('Confidence Score (%)')
        axes[1, 0].set_title('Confidence Trend (Last 10 Queries)')
        axes[1, 0].grid(True, alpha=0.3)
        axes[1, 0].set_ylim(0, 105)

        # 4. Response Type Performance
        response_types = [entry['response_type'] for entry in self.conversation_history]
        type_counts = Counter(response_types)

        axes[1, 1].bar(type_counts.keys(), type_counts.values(),
                      color=['#1abc9c', '#f39c12', '#c0392b'], alpha=0.7, edgecolor='black')
        axes[1, 1].set_xlabel('Response Type')
        axes[1, 1].set_ylabel('Count')
        axes[1, 1].set_title('Response Type Frequency')
        axes[1, 1].grid(True, alpha=0.3, axis='y')

        plt.tight_layout()
        plt.show()

        # Print summary statistics
        print("\n" + "="*60)
        print(" PERFORMANCE SUMMARY")
        print("="*60)
        print(f"Total Queries Processed: {len(self.conversation_history)}")
        print(f"Average Confidence Score: {np.mean(confidences):.2f}%")
        print(f"Highest Confidence: {max(confidences):.2f}%")
        print(f"Lowest Confidence: {min(confidences):.2f}%")
        print(f"FAQ Matches: {self.query_types['faq_match']}")
        print(f"Small Talk: {self.query_types['small_talk']}")
        print(f"No Match: {self.query_types['no_match']}")
        print("="*60)

"""---

##  STEP 4: Demo Function

### What This Does
Creates an interactive chatbot session with:
- Automated test queries (shows various capabilities)
- Live chat mode (you can ask your own questions)
- Special commands:
  - `quit` or `exit` - End the session
  - `history` - View conversation log
  - `stats` - See analytics summary

### Demo Flow
1. Shows automated test queries with results
2. Lets you interact freely
3. Generates performance visualizations at the end
"""

# STEP 4: DEMONSTRATION & TESTING


def run_enhanced_demo():
    """Run comprehensive demo of the enhanced chatbot"""

    print("=" * 70)
    print(" ENHANCED SMART FAQ CHATBOT AI AGENT - DEMO")
    print("=" * 70)
    print("Features: FAQ Matching | Small Talk | Confidence Scoring | Analytics")
    print("Commands: 'quit' to exit | 'history' for log | 'stats' for analytics")
    print("=" * 70)
    print()

    agent = EnhancedFAQAgent()

    # Automated test queries showcasing different capabilities
    test_queries = [
        # Small talk
        "Hello!",
        "How are you doing?",

        # FAQ queries with variations
        "when are you open?",
        "i forgot my password can you help",
        "what's your refund policy",
        "how do i track my package",
        "payment methods",

        # Edge case
        "something completely random xyz123",

        # Gratitude
        "thanks for the help"
    ]

    print(" Running Automated Test Queries...\n")

    for query in test_queries:
        print(f" User: {query}")
        result = agent.respond(query)

        print(f" Agent: {result['response']}")
        print(f"    Confidence: {result['confidence']:.1f}%", end="")

        if result['status'] == 'success':
            print(f" |  Matched: {result['matched_faq']}")
        elif result['status'] == 'small_talk':
            print(f" |  Type: {result['category']}")
        else:
            print()

        print("-" * 70)

    print("\n Automated tests completed!")
    print("\n Now you can try your own questions!\n")

    # Interactive mode
    while True:
        user_input = input(" You: ").strip()

        if user_input.lower() in ['quit', 'exit']:
            print("\n Agent: Thank you for using our service. Goodbye! ")
            break

        if user_input.lower() == 'history':
            analytics = agent.get_analytics()
            print("\n Conversation History:")
            print("-" * 70)
            for i, entry in enumerate(analytics['conversation_history'], 1):
                print(f"{i}. [{entry['timestamp']}] {entry['user_query']}")
                print(f"   Type: {entry['response_type']} | Confidence: {entry['confidence']:.1f}%")
            print("-" * 70)
            continue

        if user_input.lower() == 'stats':
            analytics = agent.get_analytics()
            print("\n Chatbot Statistics:")
            print("-" * 70)
            print(f"Total Queries: {analytics['total_queries']}")
            print(f"Average Confidence: {analytics['average_confidence']}%")
            print(f"Query Distribution: {analytics['query_distribution']}")
            print("-" * 70)
            continue

        if not user_input:
            continue

        result = agent.respond(user_input)
        print(f"\n Agent: {result['response']}")
        print(f"   Confidence: {result['confidence']:.1f}%\n")

    # Show visualizations at the end
    print("\n Generating Performance Visualizations...")
    agent.visualize_performance()

    return agent

"""---

##  STEP 5: Performance Evaluation Function

### What This Does
Comprehensive testing with:
- 10 diverse test cases
- Expected vs actual results comparison
- Accuracy calculation
- Visual performance charts

### Test Categories
1. Paraphrase matching
2. Keyword extraction
3. Partial phrase matching
4. Small talk detection
5. Irrelevant query handling
"""

# STEP 5: PERFORMANCE METRICS

def evaluate_with_visualization():
    """Comprehensive evaluation with visual results"""

    print("\n" + "="*70)
    print(" AGENT PERFORMANCE EVALUATION")
    print("="*70)

    agent = EnhancedFAQAgent()

    # Comprehensive test cases
    test_cases = [
        # (query, expected_match, description)
        ("what time do you open", True, "Paraphrase test"),
        ("password reset help", True, "Keyword matching"),
        ("refund policy", True, "Partial phrase"),
        ("hello", True, "Small talk - greeting"),
        ("thank you", True, "Small talk - gratitude"),
        ("completely random unrelated query xyz", False, "Irrelevant query"),
        ("track order status", True, "Synonym test"),
        ("payment options", True, "Alternative phrasing"),
        ("how are you", True, "Small talk - wellbeing"),
        ("mobile app download", True, "Keyword extraction")
    ]

    results = []

    for query, should_match, description in test_cases:
        result = agent.respond(query)
        is_match = result['status'] in ['success', 'small_talk']
        correct = (is_match == should_match)

        results.append({
            'query': query,
            'expected': should_match,
            'actual': is_match,
            'correct': correct,
            'confidence': result['confidence'],
            'description': description
        })

        status = " PASS" if correct else " FAIL"
        print(f"{status} | {description:20} | '{query}' | Conf: {result['confidence']:.1f}%")

    # Calculate metrics
    accuracy = (sum(1 for r in results if r['correct']) / len(results)) * 100
    avg_confidence = np.mean([r['confidence'] for r in results])

    print("\n" + "="*70)
    print(f" Overall Accuracy: {accuracy:.1f}%")
    print(f" Average Confidence: {avg_confidence:.1f}%")
    print(f" Correct Predictions: {sum(1 for r in results if r['correct'])}/{len(results)}")
    print("="*70)

    # Visualization of test results
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Test case results
    categories = [r['description'][:15] for r in results]
    confidences = [r['confidence'] for r in results]
    colors_list = ['green' if r['correct'] else 'red' for r in results]

    ax1.barh(categories, confidences, color=colors_list, alpha=0.7)
    ax1.set_xlabel('Confidence Score (%)')
    ax1.set_title('Test Case Performance')
    ax1.axvline(x=50, color='black', linestyle='--', alpha=0.5, label='50% threshold')
    ax1.legend()

    # Accuracy pie chart
    correct_count = sum(1 for r in results if r['correct'])
    incorrect_count = len(results) - correct_count

    ax2.pie([correct_count, incorrect_count],
            labels=['Correct', 'Incorrect'],
            autopct='%1.1f%%',
            colors=['#2ecc71', '#e74c3c'],
            startangle=90)
    ax2.set_title(f'Overall Accuracy: {accuracy:.1f}%')

    plt.tight_layout()
    plt.show()

"""---

##  STEP 6: RUN THE CHATBOT

### What Happens When You Run This
1.  Shows automated test queries (9 examples)
2.  Opens interactive chat mode
3.  You can ask your own questions
4.  Generates analytics charts when you type `quit`


"""

# STEP 6: RUN THE AGENT

if __name__ == "__main__":
    print(" Initializing Enhanced Smart FAQ Chatbot AI Agent...")
    print()

    # Run the interactive demo
    agent = run_enhanced_demo()

    print("\n" + "="*70)
    print("Running Performance Evaluation...")
    print("="*70)

    # Run evaluation
    evaluate_with_visualization()

    print("\n All demonstrations completed successfully!")
    print(" Take screenshots of the visualizations for your PPT!")
    print("="*70)